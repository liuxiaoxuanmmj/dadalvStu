# 软件工程概述

### 软件的定义

软件=程序+数据+文档，其中程序为可执行部分，数据和文档为不可执行部分

在这里数据指的是程序能正常操纵信息的数据结构

### 软件的特征：

开发的或工程化的，不是制造的

开发环境对产品影响较大

软件生产是简单的拷贝

软件测试非常困难

开发进度几乎没有客观衡量标准

维护易产生新的问题

### 软件危机

定义：在计算机软件的开发和维护过程中所遇到的一系列严重问题（效率和质量下降）

产生原因：

客观：软件本身具有逻辑部件、规模庞大的特点

主观：不正确的开发方法，比如忽视需求分析、轻视软件维护、错误地认为软件开发=程序编写

##### 解决办法：软件工程



### 软件工程

定义：(1)应用系统化的、学科化的、定量的方法，来开发、运行和维护软件，即将工程应用到软件

(2):以及对(1)中各种方法的研究

#### 软件工程三要素

方法、工具、过程

工具：它为软件工程的过程和方法提供自动化或半自动化的工具支持。 将若干工具集成起来，与软件工程数据库和计算机系统构成一个支持软件开发的系统称“计算机辅助软件工程(CASE)”，系统中某一工具的信息加工结果可以作为另一工具的输入。 集成的软件工程工具再加上人的因素构成了软件工程环境。

方法：软件工程方法是完成软件工程项目的技术手段。它支持项目计划和估算、系统和软件需求分析、设计、构造(编程)、测试和维护。软件工程方法依赖一组原则，它贯穿软件工程的各个环节。软件工程方法分两类：结构化方法和面向对象方法。

过程：过程贯穿软件开发的各个环节，在各环节之间建立里程碑； 管理者在软件工程过程中对软件开发的质量、进度、成本进行评估、管理和控制； 技术人员采用相应的方法和工具生成软件工程产品（模型、文档、数据、报告、表格等）。

#### 应用软件工程的原因

将问题分解？



### 一些对软件工程的误解

#### 管理方的误解:

M1: 我们已经有一本关于软件生产的标准和过程的书，这还不能让我们学习到需要的知识吗？

R1: 相比最新的大型主机，工作站和PC，这会使我们在做高质量软件开发时花费更多时间。

M2: 如果我们项目进度落后了，可以加入更多的程序员来赶进度。

R2: 软件开发的机制和手工作业不一样。在一个延迟了的软件项目中加入新的开发人员只会让它延迟更多。

M3: 如果我们将软件项目外包给第三方，我们就轻松了，让那个公司去完成它吧。

R3: 如果组织管理方不懂得如何从内部管理和控制软件项目，即使将项目外包也无济于事

#### 客户方的误解

M1: 对目标的一般陈述就足以开始编程，我们可以今后再补充细节。

R1: 前期糟糕的项目需求定义，是导致软件失败的主要原因。

R2: 项目需求的确在不断变化，但变化所产生的影响是根据变化提出的时间不同而不同的。

一般来说，需求变化对变更成本的影响随项目的深入而加大，在定义阶段的改变花费为1x，开发阶段为1.5-6x，但在发布以后剧增为60-100x

#### 开发人员的误解

软件从业者积累了50 年的编程文化。在早期的软件开发中，编程被视为一种艺术形式。

M1: 一旦我们编程完毕并成功运行，我们的工作就结束了。

R1: “越早开始写代码，我们就会花费越长的时间去完成它”。工业数据显示，软件开发60%-80%的精力将耗费在软件首次提交给用户以后。

M2: 当我的程序运行之前，我没有办法评估它的质量。

R2: 一个最有效的软件质量保证机制应当在项目的正式开始启动时——可以通过技术报告体现。

M3: 唯一可交付的工作成果是一个成功运行的项目程序。

R3: 一个可运行的程序只是软件结构的一部分，它还包含了许多其它因素。

M4: 软件工程将会让我们去创建大量不必要的文档，并且总是使我们的进度放慢。软件工程仅仅是文档而已。

R4: 软件工程并不是创建文档，而是创建质量。更好的质量减少返工的概率。更少返工会让项目更早交付。所有的文档都是提高团队沟通和质量所必须的。



# 软件过程

### 软件生命周期

定义：软件产品或软件系统从设计、投入使用到被淘汰的全过程

问题定义

可行性研究

需求分析

总体设计

详细设计

编码

测试

维护

### 软件过程

#### 定义

软件工过程是在工作产品构建过程中，所需完成的工作活动、动作和任务的集合

#### 软件工程模型

是软件开发全部过程、活动和任务的结构框架。它能直接表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略

也常被称为软件开发模型、软件生存周期模型、软件工程范型



### 常见的软件过程模型

#### 瀑布模型

**第一个**软件过程模型，软件开发过程与软件生命周期一致，也称**经典生命周期模型**

是一种使用广泛、**以文档为驱动**的模型

是一种**线性模型**，阶段间具有顺序性和依赖性

**推迟实现**的观点

可行性研究

​            需求分析

​                        总体设计

​									详细设计

​                                                编码

​                                                            单元测试

​                                                                        系统测试

​                                                                                    验收测试

​                                                                                                运行与维护 

缺点：增加工作量、开发风险大、早期错误发现晚、不适应需求变化

适用场合：系统需求明确且稳定、技术成熟、工程管理较为严格的场合，如军工、航天、医疗

#### V模型

ch2 p18

#### 原型模型

ch2 p23

优点：

**减少需求不明确带来的风险**

缺点：

构造原型采用的技术和工具不一定主流

快速建立起来的系统加上连续的修改可能导致原型质量低下

设计者在质量和原型中进行折中

客户意识不到一些质量问题

适用场合：客户定义一个总体目标集，但是他们并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式。

#### 增量模型

ch2 p27

优点：

增量概念的引入，不需要提供完整的需求，**只要有一个增量出现，开发就可以进行**。同时软件能够更早投入市场

在项目的初始阶段**不需要投入太多的人力资源**

**产品逐步交付**，软件开发能较好地适应需求的变化；能够看见软件中间产品，提出改进意见，减少返工，降低开发风险

**开放式体系结构**，便于维护 

缺点：

每个增量必须提供一些系统功能，这使得**开发者很难根据客户需求给出大小适合的增量**

软件**必须具备开放式体系结构**（困难）

**易退化成边做边改的方式**，使软件过程控制失去整体性

适用场合：适用于软件开发中需求可能发生变化、具有较大风险、或者希望尽早进入市场的项目

#### 螺旋模型

ch2 p36

优点：

**螺旋模型强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期**，这将有助于目标软件的适应能力，支持用户需求的动态变化

**原型可看作可执行的需求规格说明**，易于为用户和开发人员共同理解，还可作为继续开发的基础，并为用户参与所有关键决策提供了方便

**螺旋模型为项目管理人员及时调整管理决策提供了方便**，进而可降低开发风险

缺点：

如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟交付时间

使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高，否则会带来更大风险

适用场合：适用于需求不明确或者需求可能发生变化的大型复杂的软件系统。支持面向过程、面向对象等多种软件开发方法，是一种具有广阔前景的模型

#### 喷泉模型

ch2 p42

优点：

**喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发**，可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程

缺点：

**由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，因此不利于项目的管理**

**喷泉模型要求严格管理文档，使得审核的难度加大**，尤其是面对可能随时加入的各种信息、需求与资料的情况

适用场合：适用于面向对象开发

#### **敏捷软件开发**

ch2 p50

优点：

快速相应变化和不确定性

可持续开发速度

适应商业竞争环境下的有限资源和有限时间

缺点：

测试驱动开发可能导致通过测试但非用户期望

重构而不降低质量比较困难

适用场合：适用于需求模糊且经常改变的场合，适合商业竞争环境下的项目



### 如何选择

1.**前期需求明确**的情况下，尽量采用瀑布模型

2.**用户无系统使用经验，需求分析人员技能不足**的情况下，尽量借助原型模型

3.**不确定因素很多，很多东西无法提前计划**的情况下，尽量采用增量模型或螺旋模型

4.**需求不稳定**的情况下，尽量采用增量模型

5.**资金和成本无法一次到位**的情况下，可采用增量模型

6.**希望尽早投入市场**的情况下，可采用增量模型

7.对于**完成多个独立功能开发**的情况，可在需求分析阶段就进行功能并行，**每个功能内部**

都尽量遵循瀑布模型

8.**全新系统的开发**必须在总体设计完成后再开始增量或并行

9.**编码人员经验较少**的情况下，尽量不要采用敏捷模型

10.增量和原型可以综合使用，但每一次增量都必须有**明确的交付和出口原则**



# 需求分析

### 需求分析的概念

确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景

换句话说需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的陈述的一个集合

### 需求分析的过程：需求确认与需求变更

### 需求确认的步骤：需求获取→需求提炼→需求描述→需求验证

#### 需求获取：

指的是软件需求的来源、软件工程师收集这些软件需求的方法

在需求获取过程中，尽可能地分析清楚哪些是稳定的需求，哪些是易变的需求

#### 需求提炼(分析)：

定义：对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化、最终形成下一步的需求规格说明书

需求提炼（需求分析）的**核心**在于**建立分析模型**

需求提炼（需求分析）采用多种形式描述需求，通过建立需求的**多种视图**，揭示出一些更深的问题

需求提炼（需求分析）还包括与客户的交流以澄清某些易混淆的问题，并明确**哪些需求更为重要**，其目的是确保所有风险承担者尽早地对项目**达成共识**并对将来的产品有个相同而清晰的认识

#### 需求描述（需求规格说明书）:

软件需求规格说明书（SRS），是对待开发系统的行为的完整描述。包含了功能性需求和非功能性需求

需求分析工作**完成的一个基本标志**是形成了一份完整的、规范的需求规格说明书

需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础

#### 需求验证：

需求验证的重要性在于及时纠错，以降低变更成本

**对需求文档需执行以下类型的检查：**

（1）有效性检查

检查不同用户使用不同功能的有效性。

（2）一致性检查

在文档中，需求之间不应该冲突。

（3）完备性检查

需求文档应该包括所有用户想要的功能和约束。h

（4）现实性检查

检查保证能利用现有技术实现需求。

### 需求分析三类建模：功能模型、数据模型、行为模型。面向对象的需求分析过程中，三类模型各包含哪些内容？UML图类型有哪些？

#### 面向对象的需求分析

数据模型(对象模型)：描述系统数据结构的对象模型

类图、类关系图

功能模型：描述系统功能

用例图

行为模型（动态模型）：描述系统控制结构

活动图、时序图、状态图

#### UML图类型



### 掌握用例图和活动图作法。泳道划分活动图、分支及合并、分叉及汇合

#### 用例图

ch3 p33

用例：对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果。用例名往往用动宾结构命名

##### 用例之间的关系

ch3 p45

关联：表示参与者与用例之间的通信，任何一方都可发送或接收消息。

箭头指向消息接收方

泛化：即继承

箭头指向父用例

包含（Include）：用来把一个较复杂用例所表示的功能分解成较小的步骤。

在执行基本用例时，一定会执行包含用例部分

箭头指向分解出来的功能用例

扩展（Extend）：指用例功能的延伸，相当于为基础用例提供一个附加功能。

一个基本用例执行时，可以执行、也可以不执行扩展用例部分

箭头指向基础用例

#### 活动图

ch3 p54

转换可以**分支及合并**，即**可选**计算线程

转换也可以**分叉及汇合**，即**并发（并行）**计算线程





# 软件设计

软件设计定义为软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果

### 系统设计分为概要设计和详细设计

#### 概要设计（总体设计）

基本目的就是回答“概括地说，系统应该**如何实现**”这个问题

概要设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由**哪些模块**组成的，以及这些**模块相互间的关系**

步骤

输入：需求规格说明书

1.设想供选择的方案

2.选取合理的方案

3.推荐最佳方案

4.功能分解

5.设计软件结构

6.设计数据库

7.制定测试计划

8.书写文档

9审查和复审

输出：概要设计文档

#### 详细设计

根本目标：确定应该怎样**具体地实现所要求的系统**

详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”

详细设计的结果基本上决定了最终的程序代码的质量

输入：概要设计文档

输出：详细设计文档

模块的设计细化

结构化设计方法

面向对象设计方法

### 与设计相关的8个概念：抽象、体系结构、设计模式、模块化、信息隐藏、功能独立、细化、重构。系统设计从体系结构、数据、接口和组件四方面进行设计。

#### 1.抽象

含义：忽略具体的信息将不同事物看成相同事物的过程

抽象机制：参数化、规范化

规范化抽象：

数据抽象：描述数据对象的冠名数据集合

过程抽象：具有明确和有限功能的指令序列

#### 2.体系结构

定义：软件的整体结构和这种结构为系统提供概念上的完整性的方式

体系结构设计可以使用大量的一种或多种模型来表达：

结构模型

框架模型

动态模型

过程模型

功能模型

？

#### 3.设计模式

含义：在给定上下文环境中一类共同问题的共同解决方案

微观结构：

实体模式

结构模式

行为模式

#### 4.模块化

含义：软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求

软件的模块性：程序可被智能管理的单一属性？

模块化的理论依据：基于人类解决问题的观测数据

模块化的目的：使一个复杂的大型程序能被人的智力所管理

模块化和软件成本：随着模块个数的增加，模块成本逐渐降低，集成成本逐渐增加，总成本先降低后增加，其间存在一个最小代价区间

如何确定最小代价区间？？

模块化设计标准：

模块化的分解性：可分解为子问题 

模块化的组合性：组装可重用的组件 

模块化的可理解性：可作为独立单元理解 

模块化的连续性：需求小变化只影响单个模块 

模块化的保护：模块内异常只影响自身 

#### 5.信息隐藏

模块应该具有彼此相互隐藏的特性，即：模块定义和设计时应当保证模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问

特点：

抽象有助于定义构成软件的过程（或信息）实体

信息隐藏原则 定义和隐藏了模块内的过程细节以及模块内的本地数据结构

#### 6.功能独立

含义：每个模块只负责需求中特定的子功能，并且从程序结构的其他部分看，该模块具有简单的接口

好处：

易于开发：功能被划分、接口被简化

易于维护（和测试）：次生影响有限、错误传递减少，模块重用



定性衡量标准：

内聚性：模块的功能相对强度

耦合性：模块之间的相互依赖程度

模块独立性强 = 高内聚低耦合

##### 关于耦合和内聚

##### 耦合

ch4  p29 

耦合强弱取决于模块间接口的复杂程度

内容耦合：

一个模块访问另一个模块的内部数据

一个模块不通过正常入口而转到另一个模块的内部 

两个模块有一部分程序代码重叠（只可能出现在汇编程序中）

一个模块有多个入口（这意味着一个模块有几种功能）

##### 采取下述设计原则：

尽量使用数据耦合，少用控制耦合和外部耦合，限制公共环境耦合的范围，**完全不用内容耦合**。



##### 内聚

内聚衡量一个模块内部各个元素彼此结合的紧密程度

内聚和耦合密切相关，模块内的高内聚往往意味着模块间的低耦合

模块内所有处理元素属于一个整体，完成一个单一的功能，称为功能内聚。功能内聚是最高程度的内聚



#### 7.精化

含义：逐步求精的过程

与抽象的关系：

抽象使设计师确定过程和数据，但不局限于底层细节

精化有助于设计者在设计过程中揭示底层细节

#### 8.重构

含义：不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术

方法：

检查现有设计的冗余情况、未使用的设计元素、无效或不必要的算法、较差的构建方式或不恰当的数据结构，或任何其他可被更改从而优化设计的问题

### 面向对象的系统设计，各自包含哪些设计内容？

注意点：

对接口进行设计

发现变化并且封装它

先考虑聚合然后考虑继承：如何理解聚合优于继承？

#### 面向对象基本设计原则

ch4 p80

开闭原则

Liskov替换原则

依赖倒置原则

接口分离原则

发布复用等价性原则

共同封装原则

共同复用原则

### 面向对象设计活动

#### 系统架构设计

架构设计的目的是要勾画出系统的总体结构，这项工作由经验丰富的架构设计师主持完成。

输入：用例模型、分析模型。

输出：物理结构、子系统及其接口、概要的设计类。

#### 用例设计

#### 类设计

包括边界类、控制类、实体类

##### 步骤：

1.定义类的属性

2.定义类的操作

3.定义类之间的关系

类与类之间的关系：

ch4 p102

关联、聚合、组合、依赖、泛化（继承）

#### 数据库设计

#### 用户界面设计



### 掌握类图和顺序图作法

#### 对象创建的两种方法:

顺序图中的对象的默认位置是在图的顶部，如果对象在这个位置上，那么说明在发送消息时，该对象就已经存在了；

如果对象是在执行的过程中创建的，那么它的位置应该处在图的中间部分。

#### 顺序图示例

ch4 p136



# 质量保证

## 软件质量的概念和关键点

**软件质量**：明确表示是否符合功能和性能要求，明确地记载开发标准和所有专业开发软件的期望的隐形特点

**关键点：**

符合明确规定的功能和性能要求

符合明确的开发标准

符合所有软件开发专业的共性、隐性标准，如易用性、可维护性等

## 测试策略V模型概念，软件测试与开发的各阶段对应关系

**软件测试策略含义**：软件测试策略为软件开发人员、质量保证组织、和客户提供了一个路线图；规定了测试的主要步骤

### V模型

V模型非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间各阶段的**对应关系**：

**单元测试<----->详细设计**

**集成测试<----->概要设计**

**验收测试<----->需求分析**

**系统测试<----->用户需求**

## 单元测试的内容、集成测试的分类、系统测试的分类、验收测试的分类

### 单元测试

单元测试：针对软件设计的最小单位——程序模块进行正确性检验的测试工作

单元内涵：不同环境含义不同，面向过程：函数、过程等；面向对象：类、类中成员方法等

测试方法：单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试

主要依据：详细设计

测试主要内容：

ch5 p27

模块接口、局部数据结构、边界条件、独立路径、出错处理

### 集成测试

集成测试中所使用的对象应该是已经经过单元测试的软件单元

#### **分类**

（1）自顶向下的集成方法

基本思想：该集成方式将模块按系统程序结构，沿控制层次自顶向下进行集成

深度优先？广度优先？

（2）自底向上的集成方法

基本思想：从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成以进行测试

实际工作中常综合使用自顶向下的集成方法和自底向上的集成方法

（3）SMOKE方法

基本思想：冒烟测试就是在每日build（构建版本）？建立后，对系统的基本功能进行简单的测试。这种测试强调程序的主要功能进行的验证，而不会对具体功能进行更深入的测试

### 系统测试

软件开发过程必不可少的一环，软件质量保证的最重要环节

#### **功能测试**

含义：在规定的一段时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误

测试方法：黑盒测试？

#### **性能测试**

含义：检查系统是否满足在需求说明书中规定的性能

常常与压力测试结合进行，硬件和软件检测同时进行

#### **压力测试**

在系统运行环境不正常乃至发生故障的情况下，系统可以运行到何种程度的测试

#### **恢复测试**

是要证实在克服硬件故障后，系统能否正常地继续进行工作，并不对系统造成任何损害

#### **安全性测试**

是要检验在系统中已经存在的系统安全性、保密性措施是否发挥作用，有无漏洞

### 验收测试

#### **主要形式**

##### （1）根据合同的验收测试

系统测试子集再测试

##### （2）用户验收测试

客户、最终用户

##### （3）现场测试

α测试：用户在开发环境、模拟用户在实际操作环境下的测试，以评价FLURPS特性（功能、本地化、可使用性、可靠性、性能和支持）

β测试：多个用户在实际使用环境下进行测试，这些用户返回有关错误信息给开发者。而开发者通常不在测试现场，是在无法控制的环境下进行的软件现场应用

## 回归测试的概念、测试技术常见术语的概念：软件缺陷、验证和确认、测试与质量保证、质量与可靠性、调试与测试、测试用例

### 回归测试

指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其制定的需求

### 软件缺陷

软件缺陷是指系统或系统部件中那些导致系统或部件不能实现其功能的缺陷

如：

软件未实现产品说明书要求的功能

软件出现了产品说明书指明不能出现的错误

软件实现了产品说明书未提到的功能

软件未实现产品说明书虽未明确提及但应该实现的目标

软件难以理解、不易使用、运行缓慢或者— —从测试员的角度看——最终用户会认为不好

### 验证和确认

#### 验证

保证软件特定开发阶段的输出已经正确完整地实现了规格说明

#### 确认

对于每个测试级别，都要检查开发活动的输出是否满足具体的需求或与这些特定级别相关的需求

验证目标：是否正确地构造了软件？

确认目标：是否构造了正确的软件？

### 测试与质量保证

#### **软件测试**

找出软件缺陷，并确保修复

#### **软件质量保证**

创建、执行改进过程并防止缺陷的标准和方法

### 质量与可靠性

功能性、可靠性、可维护性、可用性、效率、可移植性

### 调试与测试

#### **软件测试**

目标是发现软件缺陷的存在

#### **软件调试**

目标是定位与修复缺陷

### 测试用例

是测试输入、执行条件、以及预期结果的集合，是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合

## 白盒测试、黑盒测试、静态分析各有哪些方法？

### 白盒测试

把测试对象看做一个透明盒子，允许利用程序内部逻辑结构及有关信息，进行测试。通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。又称为结构测试或逻辑驱动测试。

#### 语句覆盖

语句覆盖就是设计若干个测试用例，运行被测试程序，使得每一可执行语句至少执行一次

#### 分支覆盖

分支覆盖就是设计若干个测试用例，运行被测试程序，使得程序中每个判断的取真分支和取假分支至少经历一次。分支覆盖又称为判定覆盖

#### 条件覆盖

设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次

#### 条件组合覆盖

设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次

### 黑盒测试

测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明，又叫做功能测试或数据驱动测试。

#### 等价类划分

**基本思想**：把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据做为测试用例

**测试步骤：**

划分等价类

选取测试用例

**等价类**：某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的

**有效等价类**：对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合

**无效等价类**：对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合

两者需要同时考虑

##### 原则:

(1)如果输入条件规定了取值范围，或值的个数，则可以确立一个有效等价类和两个无效等价类

(2)如果输入条件规定了输入值的集合，或者规定了“必须如何”的条件，这时可确立一个有效等价类和一个无效等价类

(3)如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类

(4)如果规定了输入数据的一组值，而且要对每个输入值分别进行处理。可为每一个输入值确立一个有效等价类，所有不允许的输入值集合为一个无效类

(5)如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）

##### 步骤

ch5 p107

（1）确定等价类

（2）建立等价类表，列出所有划分出的等价类

（3）为每一个等价类规定一个唯一编号

（4）设计一个新的测试用例，尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止

（5）设计一个新的测试用例，仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止

### 静态分析

**含义**：不运行程序，通过检查和阅读等手段来发现错误并评估代码质量的测试技术

**分类:**

同事审查

走查：开发组内部进行

审查：以会议形式，由开发组、测试组和相关人员联合进行

### 掌握覆盖测试、等价类划分测试方法。（有效等价类和无效等价类划分、对应测试用例的设计）边界测试方法

#### 覆盖测试中，分支覆盖、条件覆盖、条件组合覆盖的辨析？？？



#### 边界测试方法

方法：确定边界情况，选取正好等于，刚刚大于，或刚刚小于边界的值做为测试数据

是对等价类划分方法的补充

原因：大量的错误是发生在输入或输出范围边界上，边界测试可以查出更多的错误

##### 单侧边界

（1）单侧边界为闭区间

选择边界点、边界点加一个步长的点和边界点减一个步长的点设计测试用例

（2）单侧边界为开区间

选择边界点、边界点范围内方向移动一个步长的点设计测试用例

**区间范围**

涉及3个测试点，

上点：即边界上的点，不管是开区间还是闭区间

内点：上点范围内的任意一点

离点：离上点最近的点称为离点。开区间为上点范围内加一个步长，闭区间为上点范围外加一个步长

（1）闭区间

例如：

学生成绩管理系统的成绩输入中，输入分数范围为[85,100]，则成绩等级为优秀，采用边界值分析法设计测试用例

上点：85、100

内点：93

**离点**：84、101

所以测试用例为{85、100、93、84、101}

（2）开区间

如上例题，输入分数范围变为（85,100）

上点：85、 100

内点：88

**离点**：86、 99

（3）半开半闭区间

如上例题，输入分数范围变为[85,100)

上点：85、 100

内点：88

**离点**：84、 99

#### 课堂作业ch5 p118



# 项目管理

## 项目管理四要素：人员、产品、项目、过程（概念）

### 人员

高级管理者：负责定义业务问题

项目管理者：计划、激励、组织和控制软件开发人员

开发人员：拥有开发产品或应用软件所需技能的人员

客户：阐明软件需求的人员

最终用户：直接使用或者与软件产品交互的人

### 产品

确定软件范围、进行功能分解

### 过程

根据项目特征选择合适的过程模型，根据过程模型进行项目分解

### 项目

采用确保软件团队能够成功的方式来组织项目

## 软件度量有哪些方法

### 面向规模的度量

通过对质量和（或）生产率的测量进行规范化而得到的，这些测量是根据开发过的软件的规模得到的

**千行代码（ KLOC ）**： 这些代码指的是源代码，通过源代码的行数来直观度量一个软件程序有多大规模

**生产率（PM）**：PM = L / E, L表示代码总量(单位：KLOC)，E表示软件工作量(单位：人月) 

**每千行代码的平均成本（ CKL ）**：CKL = S / L，S为软件项目总开销 ， L表示代码总量(单位：KLOC)

**代码出错率（EQRl）**：EQRl = Ne / L，Ne表示代码出错的行数，L表示代码总量(单位：KLOC)

**文档与代码比（Dl）**：Dl = Pd / L，Pd表示文档页数， L表示代码总量(单位：KLOC)

#### 优点

简单易行，自然直观

#### 缺点

依赖于程序设计语言的表达能力和功能

软件开发初期很难估算出最终软件的代码行数

对精巧的软件项目不合适

### 面向功能的度量

用软件的功能表示软件的规模

应用最广泛的是功能点（Function Point, FP）法

项目开发初期就可估算出

功能点计算目前主要基于经验公式

#### 功能点计算方法

FP = UFC×TCF = UFC × (0.65 + 0.01×∑Fi) 

UFC (Unadjusted Function Component) : 未调整功能点计数, 5个信息量的“加权和”

TCF (Technical Complexity Factor): 技术复杂度因子

Fi: 14个因素的“复杂性调节值” (i =1..14)

0.65, 0.01都是经验常数，现在由国际组织根据大量项目跟踪分析获得

##### UFC计算方法

外部输入EI数×加权因子(简单=3,平均=4,复杂=6) 

外部输出EO数×加权因子(简单=4,平均=5,复杂=7) 

外部查询EQ数×加权因子(简单=3,平均=4,复杂=6) 

内部逻辑文件ILF数×加权因子(简单=7,平均=10,复杂=15) 

外部接口EIF数×加权因子(简单=5,平均=7,复杂=10)

**UFC** **＝ 上述计算值的总和（加权和）**

例：

假设每个功能要素的复杂度都是平均的。若有一个由25个数据登记表、15个报告、10个外部查询、 20个逻辑内部表单和5个接口文件组成的学生管理系统，其未调整功能点计数为：

UFC ＝（25x4） +（15x5）+（10x4）+（20x10）+（5x7） ＝ 450（个功能点）

##### 14个复杂性调节因素Fi

1. 系统需要可靠的备份和复原吗？

2. 系统需要数据通信吗？

3. 系统有分布处理功能吗？

4. 性能很关键吗？

5. 系统是否运行在既存的、高度实用化的操作系统环境中？

6. 系统需要联机数据项吗？

7. 联机数据项是否在多屏幕或多操作之间进行切换？

8. 需要联机更新主文件吗？

9. 输入、输出、查询和文件很复杂吗？
10. 内部处理复杂吗？
11. 代码需要被设计成可重用吗？
12. 设计中需要包括转换和安装吗？
13. 系统的设计支持不同组织的多次安装吗？
14. 应用的设计方便用户修改和使用吗？

复杂性调节因素值Fi 

0-没有影响  1-偶有影响  2-轻微影响  3-平均影响  4-较大影响  5-严重影响

#### 优点

与程序设计语言无关，在开发前就可以估算出软件项目的规模

#### 缺点

没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统

功能点计算主要靠经验公式，主观因素比较多